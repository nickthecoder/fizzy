To Do
=====

Edit text
    Double click a shape
        If it is ShapeText or has a child of ShapeText, then edit that
        Otherwise, create a new ShapeText
            For Shape2d parents, make the size of the ShapeText the same size as the parent.

Clip text to its size (maybe do this for ALL shapes)

Either complete ShapeText.populate or re-implment it using MetaData.

ShapeText needs stroke and fill booleans, but Shape has those on Geometry
    Should they be on Shape only (and not on ShapeText nor Geometry?)
    What is the point of multiple geometries if they share a single strokeColor and fillColor???

For Version 1
-------------

Aims
    Create circuit diagrams
    Create flow charts

Edit geometry using the GUI.

Load, Save
    Rename MetaData and improve it to be more structured.

Stencils

Edit children within a parent shape

Curves (bezier or arc or both).

Text

Copy and Paste

Soon
----

Allow Color to be specified as #rrggbb or #rrggbbaa

TestShape has some tests commented out.

Test Shape.copyInto

Create a ShapeGroup,
    then look for all "is RealShape" and implement the other half.
    Some stuff in RealShape should be moved to Shape, such as Scratch, ConnectionPoints, ControlPoints...

Add more drawing tests
    Box in Box
    Simple line

Create tests for rotated shapes.

Create tests for each of the Tools

DimensionExpression and Dimension2Expression to have an additional "expected power", which defaults to 1.
    Will error if other powers are returned

Snapping
    List of Snap : Point, + - | . AlongX, AlongY  tt, tf, ft, ff

When scaling by only x or only y, and contraining, then scale by ratios i.e 1/3 1/2 1 2 3 etc
    Would be nice to scale by 11+1/4, 1+1/3, 1+1/2, 2, 3, 4 ...
    And reduce to 3/4, 2/3, 1/2, 1/3, 1/4, 1/5 ...

Rounded corners
    Where two lines meet, back off a little, and draw a circular arc.
    Only do this in the PaeView (let isAt ignore the roundedness)?
    What about pointAlong? That MUST use it.
    If the line is not long enough, then go back HALF way, and use a smaller diameter circle.
    Can cache the data in MoveTo and LineTo, and clear the cache whenever the Geometry changes.
    Don't do it for other types of GeometryParts (such as bezier/arc etc).
    Note. MoveTo needs to look for the MoveTo or end-of-list and use the previous as its partner.
        Everything else uses the previous as its partner.
    Similarly, bevelled corners (which may be easier to write first!)
    Do this for internal/external corners, or both.


Line end type. pointy, rounded, mitred??? Use rounded for polygon, and pointy for box.

ControlPoints
    Free (can move anywhere)
    Line (along a single line of a given angle)
    Rotation (fixed distance away, from a point)
    Along geometry
        This is different to the rest of them!!!

    When scaling a shape, scale the ControlPoint relative to "relative", which will often be LocPin???    
    All of them can be bound to a given rect???
        Need "MIN_DIM" and "MAX_DIM" constants.

    Must test scaling using Shape2dHandle, Shape1dHandle and Grow varieties too.

Maybe
-----

Redo expressions???
    When parsing an expression, all operators, fields, functions etc all return a Prop, but also add to a list of Props and Lists that they depend upon.
    The PropExpression then listens to each of these, and when one changes, re-parse.

Lines joined from the MIDDLE. But when arc is created it should connect differently

Add a limit to the number of items in History.
   Each batch can be assigned a number, so memory hungy operations will cause History to dimish quicker.

Can we create a single Shape, which is an N sided regular polygon? (or star).
    May also use the same system to create lines with N intermediate points.
    Could use a special context to hold "N" for each iteration.
        Note, we'd often want the first geometry to be fixed, and the subsequent one to be iterated.
        But it would be nice to have any number of prefix and suffix items, and also any number of repeated items (usually just 1).
        Maybe a GeometryPart can be an IteratedPart, which references ANOTHER geometry section, plus an N.
           But we'd stil want N control points too (or 2N).
    Or have a "templates", where N is substituted e.g. "360deg / $N"
        This has less impact on the rest of the system.

As well as ControlPoints, can we also add sliders to control shapes. e.g. a slider to control the line width.
    (I'd actually want a slider to control the "N" in the above!)

Consider "1+1" creating a PropConstant.

Layers
    Instead of shapes being IN a layer, perhaps layers should just be a way of turning a shape's visibility on/off.
    i.e. a child shape can be in a different layer to its parent.
        Useful for turning text on/off for all shapes on a page.
    For simplisity, we could make the Shape's layer attribute NOT be a PropExpression, but a simple string.
        Note this is NOT a constant! Maybe we need a new PropValue to hold them, and strongly typed versions such as StringValue.
    A layer could have an alias, which allows it to have a different name in the GUI e.g. to change to a different language.
    As this is not a structural item, it isn't needed to be done early.

Later
-----

Implement FlipX & Y
    Is there much point? Text will be reversed!

Optimise isAt by checking the bounding box first.
    Do we want this? It wouldn't allow a shape to have part sticking out of it? e.g. a resistor with wires hanging out each end.
        It doesn't seem bad right now!
    Need to update the existing tests, so that the optimisation doesn't ruin the edge case tests!

Create an SVGDrawContext to convert to SVG.
    This can be used to in the unit tests ;-)

When designing the Glass view, allow actions from JUnit tests
    e.g. mouseDownAt( x,y ), mouseMove( x,y )
    in this way, I can test most functionality without starting JavaFX.
    In fact, I could have a view without ANY JavaFX code (including mouse events or canvases)
    Could even split the JavaFX stuff into a separate module.

Allow FList items to be MOVED, so that listeners don't hear a REMOVE and an ADD event, just a single MOVED?/CHANGED? event..

Be able to "click" a part of an expression and get to the definition.
    i.e. with : "shape3.geometry1[0].point"
    shape3 and geometry1 and [0] and point should all be "links"

Consider a "isNear" method for Angle, Double, Dimension, Dimension2 and Vector (takes a 2nd parameter for the closeness). 
    Add a TINY (double) constant. Use TINY mm for a dimension??? (or just SHORT)

Round corners without changing the Geometry.
    Any time a corner is detected, replace it with a rounded corner
    Probably done in the PageView.
    Only applies to two LineTo s in succession?

Problems
--------

When a shape is deleted, then the connections must be broken.
    How?
    I don't think it is a problem. If the end is moved, it will take on a new value.
    Saving won't be a problem either, as it will save the cached value as well as the broken formula.
    Note. We must save the "next Shape ID", otherwise reloading a document may reuse the same ID.

How are Shapes and Master Shapes related?
    I want Shapes to change if their Master Shape changes, therefore they have to be linked.
    Some properties of a Shape can be changed per-Shape (such as Pin and its control points, its text etc)
    Assume that only the properties are linked, and not the structure (i.e. each Section object is unique, and not linked).
        Then each PropExpression can either be on the master, or be overriden on the Shape.
        So PropExpression must be TWO things, either a link to the master's expression, its own expression string.
    Note, a document should be stand-alone, so it can exist without the corresponding stencil.
        Therefore a document should COPY any master shapes from the stencil into itself.
        There's a problem with Shape's ids being unique, as different stencils will have Shapes with the same id.
            Maybe forbid/discourage user-editted formulars from using IDs, only the GUI can do that (e.g. when joining/glueing shapes together).

Font sizes and Real-World sizes
    Creating floor plans, the Dimensions are LARGE, but the page size is small.
        i.e. the Shape's dimensions are scaled when drawing
    So how are Text sizes defined?
        We could use pseudo font sizes (even if we call them points), and the document defines the size of a pseudo point.
        i.e. for "normal" diagrams a point is 1/90th of an inch (or whatever the stardard is),
        but for a scaled diagram, such as a floor plan, it becomes something else.
        Units cannot be an enum, because "point" would be defined differently.
        The EvaluationContext can have this special unit (and the corresponding "Conversion" within it).

How are 2 shapes combined into one?
    Maybe the size is forced to a new constant, and each geometry item is recreated, so that the values stay the same, but the calculation is based on the new size.

Can a zig-zag connecting line have any number of segments?
    Joining two components, the zig zag can head out and in using the snap points' directions, but we may want many "way points".
    Could just rely on "magic" which allows Fizzy to generate additional Geometry parts of pre-defined expressions.
    For snapping along the lines, it could refer to a Geometry section instead of (or as an alternative to) a pair of points.

How should text be stored?
    Maybe every shape can (optionally) have a single piece of text associated with it.
        Except groups???
    Should the text have independent rotation? Yes
    The text is often a "property" of the top-level shape, in which case, how is the text edited from the
        properties dialog AND the GUI?
        Using the GUI : If text is editable AND the expression is a simple link, then edit the item the link points to.
            Could generalise this behaviour for other purposes.
    Any RealShape can have a Text section
	Double click the shape to start editing the text.

Notes
-----

Snapping
    SnapX (or Y)
    Dragging any shape with a SnapX will also move other objects using the same SnapX.
    Could even have non-rectangular snapping, either as a one-off, or as a grid (e.g. a hex grid)

    This only applies to shapes on the same level (i.e. it is the PARENT that holds the snap data).

    Each shape can define a set of snapXs, snapYs and snapPoints (in their own coordinates) that can be used to snap ITSELF
    Not to be confused with a set of CONNECTIONS (control points, lines and geometries) that other shapes can snap to.
        (Maybe only allow ONE geometry, which is used when dragging from the shape).
        What about rotations and scale etc?
            Could have a read-only calculated property for a shape's edges. (Axis aligned bounding box) that these can use.

    A shape2d's position is NOT an expression, but a SpecialDimension2Prop.
        the x and y Dimensions are either a constant or a Join.

    Likewise for a Shape1d's start and end points.


A Document should have a set of custom properties / styles that its Shapes can reference.
For example, a line width and line color which many shapes all share.
    These can be expressions, and therefore can reference other custom properties.

When a compound object such as Dimension2 is shown in the spreadsheet, we need to be able to edit is as a whole,
    or by its constituent parts.
    Show split whenever possible?

    OR any compound objects have TWO implementations of Expression, split and un-split.
        Split has two separate expression strings.
        In this way the GUI always shows in the way it was designed.
            We can still have a split/un-split button

    NOTE. Is is always possible to split an expression by duplicating the expression, and added "(blah).x" and "(blah).y"
        but if we then un-split it, it will give a horrible mess, but we could use a simple regex to see if
        merging can be done nicely without making a mess (i.e. check that both expressions are " *( *blah *).x"
        or " *blah *.x" where blah doesn't have any operators.

Much Later
----------

Add a Groovy based REPL to manipulate the data structures programatically.

Split the project into core and app, so that headless tools can manipulate Fizzy documents.
Create a separate project for useful tools, such as batch converting to SVG.
    Use paratask to parse the commands.


Useful Documents
----------------

Understanding Shape Sheets : https://msdn.microsoft.com/en-us/library/office/gg144579(v=office.14).aspx
Japanese video using shape sheets : https://www.youtube.com/watch?v=9Kyv48e22LQ
Shows shapesheet screen shots : https://stackoverflow.com/questions/28877699/new-created-custom-list-shape-doesnt-work-in-microsoft-visio-2013-x64?rq=1

To Do
=====

Test a Shape1d


Consider changing the order of field evaluation.
    Currently things like "Dimension2" are asking ShapePropType first BEFORE the global functions.
    Line 309 of Evaluator.


Allow access to other shapes
    Make Shape's id a number, and allow access to any using :
        Shape(n)
    This isn't user friendly when a Master Shape is refering to a child.
    So a shape can reference any child shape using just its NAME (which is only unique within that parent)
        ChildName
    You can also refer to a Shape's parent using Parent

Create tests for rotated shapes.
Create tests for Shape1d s
    Link a line from one shape to another, then move the shape.


Soon
----

DimensionExpression and Dimension2Expression to have an additional "expected power", which defaults to 1.
    Will error if other powers are returned

Create a JavaFX application drawing pre-created shapes.
    Add a Glass canvas to highlight the currently selected shape
    Handles section : Points which can be dragged by the user
    Snap section : Places that line ends can snap to

Maybe
-----

Consider "1+1" creating a PropConstant.

Layers
    Instead of shapes being IN a layer, perhaps layers should just be a way of turning a shape's visibility on/off.
    i.e. a child shape can be in a different layer to its parent.
        Useful for turning text on/off for all shapes on a page.
    For simplisity, we could make the Shape's layer attribute NOT be a PropExpression, but a simple string.
        Note this is NOT a constant! Maybe we need a new PropValue to hold them, and strongly typed versions such as StringValue.
    A layer could have an alias, which allows it to have a different name in the GUI e.g. to change to a different language.
    As this is not a structural item, it isn't needed to be done early.

Later
-----

NOTE. Visio has line width on Shape, not geometry. Why?
    What are multiple Geometries for?
    I'll use a Geometry for snapping, so perhaps I should follow.

Create an SVGDrawContext to convert to SVG.
    This can be used to in the unit tests ;-)

When designing the Glass view, allow actions from JUnit tests
    e.g. mouseDownAt( x,y ), mouseMove( x,y )
    in this way, I can test most functionality without starting JavaFX.
    In fact, I could have a view without ANY JavaFX code (including mouse events or canvases)
    Could even split the JavaFX stuff into a separate module.


Shape to have a list of Sections
    Geometry and ShapeTransform being sections.
    The spreadsheet's gui can then use the list and each section's meta data to create the tables.

Allow FList items to be MOVED, so that listeners don't hear a REMOVE and an ADD event, just a single MOVED?/CHANGED? event..

Be able to "click" a part of an expression and get to the definition.
    i.e. with : "shape3.geometry1[0].point"
    shape3 and geometry1 and [0] and point should all be "links"

Consider a "isNear" method for Angle, Double, Dimension, Dimension2 and Vector (takes a 2nd parameter for the closeness). 
    Add a TINY (double) constant. Use TINY mm for a dimension??? (or just SHORT)


Problems
--------

How are Shapes and Master Shapes related?
    I want Shapes to change if their Master Shape changes, therefore they have to be linked.
    Some properties of a Shape can be changed per-Shape (such as Pin and its control points, its text etc)
    Assume that only the properties are linked, and not the structure (i.e. each Section object is unique, and not linked).
        Then each PropExpression can either be on the master, or be overriden on the Shape.
        So PropExpression must be TWO things, either a link to the master's expression, its own expression string.
    Note, a document should be stand-alone, so it can exist without the corresponding stencil.
        Therefore a document should COPY any master shapes from the stencil into itself.
        There's a problem with Shape's ids being unique, as different stencils will have Shapes with the same id.
            Maybe forbid/discourage user-editted formulars from using IDs, only the GUI can do that (e.g. when joining/glueing shapes together).

Font sizes and Real-World sizes
    Creating floor plans, the Dimensions are LARGE, but the page size is small.
        i.e. the Shape's dimensions are scaled when drawing
    So how are Text sizes defined?
        We could use pseudo font sizes (even if we call them points), and the document defines the size of a pseudo point.
        i.e. for "normal" diagrams a point is 1/90th of an inch (or whatever the stardard is),
        but for a scaled diagram, such as a floor plan, it becomes something else.
        Units cannot be an enum, because "point" would be defined differently.
        The EvaluationContext can have this special unit (and the corresponding "Conversion" within it).

How is a line end (or a control point???) joined to another Shape's value?
    Using a special Join( shape, point ), where point is in a value relative to the shape's coordinates.
       This can calculate the point in the document, and then convert it back into local units.
    Ditto for JoinAlong( shape, pointA, pointB, along ), where along is usually 0..1
    Recalculated whenever the shape changes (or any of its ancestors - eek, I currently only go UPWARDS).

Should Prop<String>'s head and tail methods be safe? i.e. should they error if the string is too short?

Shape has an ID, which can be referenced by expressions in other Shapes.
    How do we change the expression TEXT when the ID is changed?
    When Evaluator is run, any time a Shape's ID is used, add a listener to the Shape's ID
        The listener knows the position of the token, and so the expression can be updated ;-)
    Clear the listeners before evaluating the expression and/or when the expression is changed.
    Are ShapeIDs unique to the whole document, or can a Shape inside a group share an ID with a Shape within a different group?

How are 2 shapes combined into one?
    Maybe the size is forced to a new constant, and each geometry item is recreated, so that the values stay the same, but the calculation is based on the new size.

How does a line join to two boxes at their edges?
    Instead of trying to head directly from each box center, snap to the edge, remembering the ratio.
    So you can snap to the middle of the edge with a ratio of 0.5, and the left with a ratio of 0.
        Then each end of the line can be independent.
    i.e. we don't snap to a BOX, but instead snap to a LINE
    We could also snap to an ellipse (with the option of setting the start and end angle of the curve.

    Snap points should also contain direction(s) of entry, so that lines can intelligently connect.
        e.g. a horizontal resistor has a 0deg on the left and 180deg on the right.

    Could also snap to a Geometry section.
        e.g. a box have 4 lines, so a ratio of 1/8th would be half way along the 1st line.
        Each GeometryPart has an "end point" (which is just the "point" for LineTo and MoveTo)
        Geometry can have an "along(n)" method, which calculates the snap point for a given "along" value.
            Would be constrained to 0..1
        Each GeometryPart has an along( from : Dimenion, n ) where from will be the previous part's end point.
        Note. GraphicsContext's arcTo and bezierCurveTo do use the previous point in the path :-)

Can a zig-zag connecting line have any number of segments?
    Joining two components, the zig zag can head out and in using the snap points' directions, but we may want many "way points".
    Could just rely on "magic" which allows Fizzy to generate additional Geometry parts of pre-defined expressions.
    For snapping along the lines, it could refer to a Geometry section instead of (or as an alternative to) a pair of points.

How should text be stored?
    Maybe every shape can (optionally) have a single piece of text associated with it.
        Except groups???
        Maybe only Shape2d has text
    Should the text have independent rotation?
    The text is often a "property" of the top-level shape, in which case, how is the text edited from the
        properties dialog AND the GUI?
        Using the GUI : If text is editable AND the expression is a simple link, then edit the item the link points to.
            Could generalise this behaviour for other purposes.
    Any RealShape can have a Text section
	Double click the shape to start editing the text.

Notes
-----

Snapping
    SnapX (or Y)
    Dragging any shape with a SnapX will also move other objects using the same SnapX.
    Could even have non-rectangular snapping, either as a one-off, or as a grid (e.g. a hex grid)

    This only applies to shapes on the same level (i.e. it is the PARENT that holds the snap data).

    Each shape can define a set of snapXs, snapYs and snapPoints (in their own coordinates) that can be used to snap ITSELF
    Not to be confused with a set of CONNECTIONS (control points, lines and geometries) that other shapes can snap to.
        (Maybe only allow ONE geometry, which is used when dragging from the shape).
        What about rotations and scale etc?
            Could have a read-only calculated property for a shape's edges. (Axis aligned bounding box) that these can use.

    A shape2d's position is NOT an expression, but a SpecialDimension2Prop.
        the x and y Dimensions are either a constant or a Join.

    Likewise for a Shape1d's start and end points.


A Document should have a set of custom properties / styles that its Shapes can reference.
For example, a line width and line color which many shapes all share.
    These can be expressions, and therefore can reference other custom properties.

When a compound object such as Dimension2 is shown in the spreadsheet, we need to be able to edit is as a whole,
    or by its constituent parts.
    Show split whenever possible?

    OR any compound objects have TWO implementations of Expression, split and un-split.
        Split has two separate expression strings.
        In this way the GUI always shows in the way it was designed.
            We can still have a split/un-split button

    NOTE. Is is always possible to split an expression by duplicating the expression, and added "(blah).x" and "(blah).y"
        but if we then un-split it, it will give a horrible mess, but we could use a simple regex to see if
        merging can be done nicely without making a mess (i.e. check that both expressions are " *( *blah *).x"
        or " *blah *.x" where blah doesn't have any operators.

Much Later
----------

Add a Groovy based REPL to manipulate the data structures programatically.

Split the project into core and app, so that headless tools can manipulate Fizzy documents.
Create a separate project for useful tools, such as batch converting to SVG.
    Use paratask to parse the commands.


Useful Documents
----------------

Understanding Shape Sheets : https://msdn.microsoft.com/en-us/library/office/gg144579(v=office.14).aspx
Japanese video using shape sheets : https://www.youtube.com/watch?v=9Kyv48e22LQ
